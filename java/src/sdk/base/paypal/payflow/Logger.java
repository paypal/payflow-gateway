package paypal.payflow;

/**
 * This program is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.TimeZone;

/**
 * This is a singleton class which can be used for logging of the messages.
 * The logger will log all the messages to the file specified in the SDKproperties class.
 * By default the logging will be switched to OFF.
 */
public final class Logger {

    // Allow requestId to be non-static in BaseTransaction for multi-threading.
    //BaseTransaction bt = new BaseTransaction();
    //String rid = bt.getRequestId();

    /**
     * This SortedList holds the Message code,Body and severity level of the messages
     * mentioned in the XML file.
     */
    private HashMap mMessages;

    /**
     * Holds the instance of this singleton class.
     */
    private static Logger mInstance;

    /**
     * Holds the errors generated by Logger class.
     */
    private ArrayList mLoggerErrs = new ArrayList();

    /**
     * This flag indicates, if an error occurred because of the Logger class.
     */
    private boolean errInLogger = false;

    /**
     * This char is used in the rolling file functionality
     */
    private static final char archiveFileSeparator = '_';

    /**
     * the sdf format is appended to messages.
     */
    private java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat("yyyy-MM-dd H:mm:ss z");

    /**
     * OutputStream object for this logger
     */
    private OutputStream os = null;

    /**
     * PrintStream object for this logger
     */
    private PrintStream out = null;

    private long logFileLength = 0;

    /**
     * This private constructor reads the config file for the name of file which contains the
     * error messages.After getting the name it loads the static member "mMessages" with
     * the messages mentioned in the file.It also initializes the Log4net instance which
     * will is used for logging.If the path for the log4net API is not available in the config
     * file, logging is not done.
     */
    private Logger() {
        populateMessages();
        if (!(SDKProperties.getLoggingLevel() >= PayflowConstants.LOGGING_OFF)) {
            if (!SDKProperties.isLogFileNameSet()) {
                String respMessage = PayflowConstants.PARAM_RESULT
                        + PayflowConstants.SEPARATOR_NVP
                        + PayflowConstants.CommErrorCodes.get(PayflowConstants.E_INIT_ERROR)
                        + PayflowConstants.DELIMITER_NVP
                        + PayflowConstants.PARAM_RESPMSG
                        + PayflowConstants.SEPARATOR_NVP
                        + PayflowConstants.CommErrorMessages.get(PayflowConstants.E_INIT_ERROR)
                        + "log file name not set. Using default values";
                ErrorObject err =
                        new ErrorObject(PayflowConstants.SEVERITY_WARN, PayflowConstants.EMPTY_STRING,
                                respMessage);
                mLoggerErrs.add(err);
                //errInLogger will not be set since logging must still happen.

            }
            if (!SDKProperties.isMaxlogFileSizeSet()) {
                String respMessage = PayflowConstants.PARAM_RESULT
                        + PayflowConstants.SEPARATOR_NVP
                        + PayflowConstants.CommErrorCodes.get(PayflowConstants.E_INIT_ERROR)
                        + PayflowConstants.DELIMITER_NVP
                        + PayflowConstants.PARAM_RESPMSG
                        + PayflowConstants.SEPARATOR_NVP
                        + PayflowConstants.CommErrorMessages.get(PayflowConstants.E_INIT_ERROR)
                        + "max log file size not set. Using default values";
                ErrorObject err =
                        new ErrorObject(PayflowConstants.SEVERITY_WARN, PayflowConstants.EMPTY_STRING,
                                respMessage);
                mLoggerErrs.add(err);
                //errInLogger will not be set since logging must still happen.
            }
            try {
                File logFile = new File(SDKProperties.getLogFileName());
                if (!logFile.exists()) {
                    if (null != logFile.getParentFile() && !logFile.getParentFile().exists()) {
                        logFile.getParentFile().mkdirs();
                    }
                    logFile.createNewFile();
                }

                logFileLength = logFile.length();
            }
            catch (IOException e) {
                String respMessage = PayflowConstants.PARAM_RESULT
                        + PayflowConstants.SEPARATOR_NVP
                        + PayflowConstants.CommErrorCodes.get(PayflowConstants.E_INIT_ERROR)
                        + PayflowConstants.DELIMITER_NVP
                        + PayflowConstants.PARAM_RESPMSG
                        + PayflowConstants.SEPARATOR_NVP
                        + PayflowConstants.CommErrorMessages.get(PayflowConstants.E_INIT_ERROR)
                        + e.getMessage() + " Occurred while accessing logFile : " + SDKProperties.getLogFileName() + " - Logging has been disabled.";
                ErrorObject err =
                        new ErrorObject(PayflowConstants.SEVERITY_WARN, PayflowConstants.EMPTY_STRING,
                                respMessage);
                mLoggerErrs.add(err);
                errInLogger = true;
            }
        }
    }

    /**
     * This will give the instance of the logger class.
     *
     * @return mInstance
     */
    public synchronized static Logger getInstance() {
        if (mInstance == null)
            mInstance = new Logger();
        return mInstance;
    }

    /**
     * Get the Errors generated due to the Logger.
     *
     * @return mLoggerErrs
     */
    public ArrayList getLoggerErrs() {
        return mLoggerErrs;
    }

    /**
     * This is a internal method and takes in a errorobject as a parameter.This method
     * then calls another overloaded version for the method Log which takes in a
     * string to be logged and the severity level of the Error Object.
     *
     * @param message ErrorObject
     */
    protected void log(ErrorObject message) {
        if (message != null) {
            log(message.toString(), message.getSeverityLevel());
        }
    }

    /**
     * This is a internal method and takes in a arraylist of the errorobjects
     * as a parameter.The method goes through the array list for each errorobject
     * found makes a call to another overloaded version of the Log method which takes
     * in ErrorObject as a parameter.If there are some errors which have been generated by
     * the Logger class then those are logged instead of the passed messages.
     *
     * @param messages ArrayList containing the error objects
     */
    protected void log(ArrayList messages) {
        int ErrCnt;
        int ErrMaxCnt;
        if (mLoggerErrs.size() != 0) {
            messages = mLoggerErrs;
        }
        ErrMaxCnt = messages.size();
        for (ErrCnt = 0; ErrCnt < ErrMaxCnt; ErrCnt++) {
            log((ErrorObject) messages.get(ErrCnt));
        }
    }

    /**
     * This method logs the data to a file.Different type of severity level can be logged here.
     * The levels that can be logged are decided by the configuration settings in the
     * SDKProperties file.
     *
     * @param message     String : value that needs to be logged
     * @param severityLvl int : Severity level of the message.This could be one of the following:
     *                    <ol>
     *                    <li> PayflowConstants.LOGGING_OFF </li>
     *                    <li> PayflowConstants.SEVERITY_FATAL </li>
     *                    <li> PayflowConstants.SEVERITY_ERROR </li>
     *                    <li> PayflowConstants.SEVERITY_WARN </li>
     *                    <li> PayflowConstants.SEVERITY_INFO </li>
     *                    <li> PayflowConstants.SEVERITY_DEBUG </li>
     *                    </ol>
     * @return retVal Boolean
     */
    public boolean log(String message, int severityLvl) {
        boolean retVal = true;
        String severity;
        Calendar cal;

        if (severityLvl >= SDKProperties.getLoggingLevel() && !errInLogger) {
            switch (severityLvl) {
                case PayflowConstants.SEVERITY_DEBUG:
                    severity = "Debug";
                    break;
                case PayflowConstants.SEVERITY_INFO:
                    severity = "Info";
                    break;
                case PayflowConstants.SEVERITY_WARN:
                    severity = "Warn";
                    break;
                case PayflowConstants.SEVERITY_ERROR:
                    severity = "Error";
                    break;
                case PayflowConstants.SEVERITY_FATAL:
                    severity = "Fatal";
                    break;
                default:
                    severity = PayflowConstants.EMPTY_STRING;
            }
            try {
                if (null != severity && severity.length() != 0) {
                    synchronized (this) {
                        if (logFileLength > SDKProperties.getMaxLogFileSize()) {
                            if (archiveLogFile()) {
                                logFileLength = 0;
                            }
                        }
                        if (null == os || null == out) {
                            os = new FileOutputStream(SDKProperties.getLogFileName(), true);
                            out = new PrintStream(os, true);
                        }
                        cal = Calendar.getInstance(TimeZone.getDefault());
                        String dRequestId = "";

                        // temp removal until figured out
                        /* if (BaseTransaction.requestId != null)  {
                          dRequestId = BaseTransaction.requestId + ":";
                        }
                        */
                        String messageToBeLogged = sdf.format(cal.getTime()) + ":" + pad(severity, 5, " ") + ":" + dRequestId + message;

                        out.println(messageToBeLogged);
                        logFileLength += messageToBeLogged.length() + 1;
                    }
                }
            } catch (Exception e) {
                retVal = false;
                String respMessage = PayflowConstants.PARAM_RESULT
                        + PayflowConstants.SEPARATOR_NVP
                        + PayflowConstants.CommErrorCodes.get(PayflowConstants.E_INIT_ERROR)
                        + PayflowConstants.DELIMITER_NVP
                        + PayflowConstants.PARAM_RESPMSG
                        + PayflowConstants.SEPARATOR_NVP
                        + PayflowConstants.CommErrorMessages.get(PayflowConstants.E_INIT_ERROR)
                        + e.getMessage() + " Occurred while accessing logFile : " + SDKProperties.getLogFileName() + " - Logging has been disabled.";
                ErrorObject err =
                        new ErrorObject(PayflowConstants.SEVERITY_WARN, PayflowConstants.EMPTY_STRING,
                                respMessage);
                mLoggerErrs.add(err);
                errInLogger = true;
            }
        }

        return retVal;
    }

    private boolean archiveLogFile() {
        boolean archived = false;
        File archivedLog;
        String fileName;
        File logFile;
        try {
            if (null != out) {
                out.flush();
                out.close();
            }
            if (null != os) os.close();
            logFile = new File(SDKProperties.getLogFileName());
            int targetPosition = SDKProperties.getLogFileName().indexOf('.');
            targetPosition = targetPosition != -1 ? targetPosition : SDKProperties.getLogFileName().length();
            for (int i = 1; ; i++) {
                fileName =
                        new StringBuffer(SDKProperties.getLogFileName())
                                .insert(targetPosition, archiveFileSeparator)
                                .insert(targetPosition + 1, Integer.toString(i))
                                .toString();
                archivedLog = new File(fileName);
                if (!archivedLog.exists()) {
                    if (logFile.renameTo(archivedLog))
                        archived = true;
                    break;
                }
            }
        } catch (Exception e) {
            archived = false;
        }
        os = null;
        out = null;
        return archived;
    }

    /**
     * This method populates each ErrorObject int the arraylist passed, with the
     * details from the SortedList held by the logger class. It populates the mLoggerErrs
     * in case the relevant message code is not found.
     * <p/>
     * Populate the error object with the details
     *
     * @param errObj ArrayList
     * @return errorObject ArrayList
     */
    protected ArrayList populateErrorDetails(ArrayList errObj) {
        ErrorObject errMesg;
        ErrorObject retErrorObj;
        ArrayList retErrObjs = new ArrayList(0);
        int errCnt;
        int errMaxCnt;
        int sevLvlAssigned;
        String[] mesgParams;

        //Iterate through all the error objects in the array list
        errMaxCnt = errObj.size();
        for (errCnt = 0; errCnt < errMaxCnt; errCnt++) {
            if (((ErrorObject) errObj.get(errCnt)).getMessageCode().length() != 0) {
                errMesg = (ErrorObject) mMessages.get(((ErrorObject) errObj.get(errCnt)).getMessageCode());

                if (((ErrorObject) errObj.get(errCnt)).getSeverityLevel() != 0) {
                    sevLvlAssigned = ((ErrorObject) errObj.get(errCnt)).getSeverityLevel();
                } else {
                    sevLvlAssigned = errMesg.getSeverityLevel();
                }
                mesgParams = new String[((ErrorObject) errObj.get(errCnt)).getMessageParams().size()];

                ((ErrorObject) errObj.get(errCnt)).getMessageParams().toArray(mesgParams);

                retErrorObj = new ErrorObject(sevLvlAssigned,
                        errMesg.getMessageCode(), errMesg.getMessageBody(),
                        mesgParams,
                        ((ErrorObject) errObj.get(errCnt)).getErrorStackTrace());
            } else {
                retErrorObj = (ErrorObject) errObj.get(errCnt);
            }
            retErrObjs.add(retErrorObj);
        }
        return retErrObjs;
    }

    private void populateMessages() {
        mMessages = new HashMap();
        ErrorObject Err;
        Err = new ErrorObject(PayflowConstants.SEVERITY_INFO, PayflowConstants.MSG_COMMUNICATION_ERROR, "RESULT={0}&RESPMSG={1}");
        mMessages.put(PayflowConstants.MSG_COMMUNICATION_ERROR, Err);
        Err = new ErrorObject(PayflowConstants.SEVERITY_INFO, PayflowConstants.MSG_COMMUNICATION_ERROR_XMLPAY, "<XMLPayResponse xmlns='http://www.paypal.com/XMLPay'><ResponseData><TransactionResults><TransactionResult><Result>{0}</Result><Message>{1}</Message></TransactionResult></TransactionResults></ResponseData></XMLPayResponse>");
        mMessages.put(PayflowConstants.MSG_COMMUNICATION_ERROR_XMLPAY, Err);
        Err = new ErrorObject(PayflowConstants.SEVERITY_INFO, PayflowConstants.MSG_COMMUNICATION_ERROR_NO_RESPONSE_ID, "RESULT={0}&RESPMSG={1}&REQUEST_ID={2}");
        mMessages.put(PayflowConstants.MSG_COMMUNICATION_ERROR_NO_RESPONSE_ID, Err);
        Err = new ErrorObject(PayflowConstants.SEVERITY_INFO, PayflowConstants.MSG_COMMUNICATION_ERROR_XMLPAY_NO_RESPONSE_ID, "<XMLPayResponse xmlns='http://www.paypal.com/XMLPay'><ResponseData><TransactionResults><TransactionResult><Result>{0}</Result><Message>{1}</Message></TransactionResult></TransactionResults></ResponseData></XMLPayResponse>");
        mMessages.put(PayflowConstants.MSG_COMMUNICATION_ERROR_XMLPAY_NO_RESPONSE_ID, Err);
    }

/**
   * Pads out a string upto padlen with pad chars
   * @param str Object.toString() to be padded
   * @param padlen length of pad (+ve = pad on right, -ve pad on left)
   * @param pad character
 * @return
   */
  private static String pad(Object str, int padlen, String pad)
    {
    String padding = new String();
    int len = Math.abs(padlen) - str.toString().length();
    if (len < 1)
      return str.toString();
    for (int i = 0 ; i < len ; ++i)
      padding = padding + pad;

    return (padlen < 0 ? padding + str : str + padding);
    }


}